from aqt import gui_hooks
from aqt.sound import av_player, SoundOrVideoTag
from aqt.utils import showInfo, tooltip
import subprocess
import os
import tempfile
import platform

# 检查系统是否为 macOS
if platform.system() != "Darwin":
    tooltip("MPV 快捷键插件仅支持 macOS 系统")

# 创建 MPV 配置文件
def create_mpv_config():
    config_dir = os.path.expanduser("~/.config/mpv")
    
    # 确保配置目录存在
    try:
        os.makedirs(config_dir, exist_ok=True)
    except Exception as e:
        tooltip(f"创建 MPV 配置目录失败: {str(e)}")
        return False
    
    # 创建 input.conf 文件
    config_path = os.path.join(config_dir, "input.conf")
    
    # 如果文件已存在，备份原文件
    if os.path.exists(config_path):
        backup_path = config_path + ".anki_backup"
        if not os.path.exists(backup_path):
            try:
                with open(config_path, "r", encoding="utf-8") as f:  # 添加 encoding="utf-8"
                    original_content = f.read()
                with open(backup_path, "w", encoding="utf-8") as f:  # 添加 encoding="utf-8"
                    f.write(original_content)
                tooltip("已备份原 MPV 配置文件")
            except Exception as e:
                tooltip(f"备份 MPV 配置文件失败: {str(e)}")
                return False
    
    # 从配置中获取自定义快捷键
    from aqt import mw
    config = mw.addonManager.getConfig(__name__) or {}
    custom_shortcuts = config.get("custom_shortcuts", {})
    
    # 构建配置文件内容 - 使用英文注释避免编码问题
    config_content = "# Generated by Anki MPV Shortcuts Plugin\n\n"  # 修改为英文注释
    # 添加鼠标滚轮控制视频进度的默认配置
    config_content += "# Mouse wheel controls for video progress\n"
    config_content += "WHEEL_UP seek 1\n"
    config_content += "WHEEL_DOWN seek -1\n\n"
    
    # 添加默认键盘快捷键
    config_content += "# Default keyboard shortcuts\n"
    config_content += "LEFT no-osd seek -2 exact\n"
    config_content += "RIGHT no-osd seek 2 exact\n"
    config_content += "UP multiply speed 1.1\n"
    config_content += "DOWN multiply speed 0.85\n"
    config_content += "a no-osd seek -2 exact\n"  # 修正了a键的命令
    config_content += "d no-osd seek 2 exact\n"   # 修正了d键的命令
    config_content += "w multiply speed 1.1\n"
    config_content += "s multiply speed 0.85\n"    # 调整了减速比例
    config_content += "e set speed 1.0\n"         # 添加e键恢复原倍速播放
    config_content += "c ab-loop\n"
    config_content += "f cycle-values loop \"inf\" \"no\"\n\n"  # 将v改为f
    
    # 添加用户自定义快捷键
    for key, action in custom_shortcuts.items():
        config_content += f"{key} {action}\n"
    
    # 写入新配置
    try:
        with open(config_path, "w", encoding="utf-8") as f:  # 添加 encoding="utf-8"
            f.write(config_content)
        return True
    except Exception as e:
        tooltip(f"创建 MPV 配置文件失败: {str(e)}")
        return False
    
    # 创建 mpv.conf 文件
    mpv_conf_path = os.path.join(config_dir, "mpv.conf")
    mpv_conf_content = """
# MPV 配置文件 - 由 Anki MPV 快捷键插件生成
save-position-on-quit=yes
watch-later-directory=~/.config/mpv/watch_later
# 加载脚本目录
script-opts=ytdl_hook-ytdl_path=yt-dlp
"""
    
    # 确保脚本目录存在
    scripts_dir = os.path.join(config_dir, "scripts")
    try:
        os.makedirs(scripts_dir, exist_ok=True)
    except Exception as e:
        tooltip(f"创建 MPV 脚本目录失败: {str(e)}")
        return False
    
    # 复制倍速循环脚本到MPV脚本目录
    speed_cycle_script = os.path.join(os.path.dirname(__file__), "speed_cycle.lua")
    speed_cycle_dest = os.path.join(scripts_dir, "speed_cycle.lua")
    
    # 如果源脚本不存在，创建它
    if not os.path.exists(speed_cycle_script):
        try:
            with open(speed_cycle_script, "w", encoding="utf-8") as f:
                f.write("""-- 倍速循环播放脚本
local speeds = {0.7, 0.8, 1.0, 1.2}  -- 定义倍速序列
local current_index = 1
local is_cycling = false
local timer = nil

function cycle_speed()
    if not is_cycling then
        return
    end
    
    -- 设置当前倍速
    mp.set_property_number("speed", speeds[current_index])
    mp.osd_message(string.format("播放速度: %.1fx", speeds[current_index]))
    
    -- 移动到下一个倍速
    current_index = current_index + 1
    
    -- 如果已经完成所有倍速，停止循环
    if current_index > #speeds then
        stop_cycling()
        return
    end
    
    -- 获取当前媒体的时长
    local duration = mp.get_property_number("duration")
    local remaining = mp.get_property_number("time-remaining")
    
    -- 设置定时器，在当前速度播放完成后切换到下一个速度
    -- 这里简化处理，实际上应该考虑剩余时间和当前速度的关系
    if timer then
        timer:kill()
    end
    timer = mp.add_timeout(remaining, cycle_speed)
end

function start_cycling()
    if is_cycling then
        stop_cycling()
        return
    end
    
    is_cycling = true
    current_index = 1
    mp.osd_message("开始倍速循环播放")
    cycle_speed()
end

function stop_cycling()
    is_cycling = false
    if timer then
        timer:kill()
        timer = nil
    end
    mp.osd_message("倍速循环播放结束")
end

-- 绑定r键触发倍速循环
mp.add_key_binding("r", "speed_cycle", start_cycling)
""")
        except Exception as e:
            tooltip(f"创建倍速循环脚本失败: {str(e)}")
            return False
    
    # 复制脚本到MPV脚本目录
    try:
        import shutil
        shutil.copy2(speed_cycle_script, speed_cycle_dest)
    except Exception as e:
        tooltip(f"复制倍速循环脚本失败: {str(e)}")
        return False
    
    try:
        with open(mpv_conf_path, "w", encoding="utf-8") as f:
            f.write(mpv_conf_content)
    except Exception as e:
        tooltip(f"创建 MPV 主配置文件失败: {str(e)}")
        return False
    
    return True

# 在 Anki 启动时设置 MPV 配置
def setup_mpv_on_startup():
    from aqt import mw  # 添加这行导入 mw
    from aqt.utils import showText
    
    # 检查 MPV 是否已安装
    config = mw.addonManager.getConfig(__name__) or {}
    mpv_path = config.get("mpv_path", "/opt/homebrew/bin/mpv")
    
    if not os.path.exists(mpv_path):
        showInfo(f"MPV 可执行文件不存在: {mpv_path}\n请在插件配置中设置正确的 MPV 路径")
        return
    
    # 创建配置文件
    if create_mpv_config():
        tooltip("MPV 快捷键配置已更新")
    else:
        # 收集调试信息
        debug_info = []
        debug_info.append(f"MPV 路径: {mpv_path}")
        debug_info.append(f"配置目录: {os.path.expanduser('~/.config/mpv')}")
        
        # 检查权限
        config_dir = os.path.expanduser("~/.config/mpv")
        if os.path.exists(config_dir):
            try:
                test_file = os.path.join(config_dir, "test_write.tmp")
                with open(test_file, "w") as f:
                    f.write("test")
                os.remove(test_file)
                debug_info.append("配置目录写入权限: 正常")
            except Exception as e:
                debug_info.append(f"配置目录写入权限: 失败 - {str(e)}")
        
        showText("\n".join(debug_info))
        showInfo("MPV 快捷键配置失败，请检查日志")

# 使用 MPV 播放音频文件
def play_with_mpv(tag):
    # 获取配置，检查插件是否启用
    from aqt import mw
    config = mw.addonManager.getConfig(__name__) or {}
    if not config.get("enabled", True):
        # 如果插件被禁用，使用原始播放器
        return False
    
    # 获取文件路径
    if isinstance(tag, SoundOrVideoTag):
        if hasattr(tag, "filename"):
            filename = tag.filename
        else:
            # 尝试获取其他可能的属性
            attrs = dir(tag)
            if "filename" in attrs:
                filename = tag.filename
            elif "path" in attrs:
                filename = tag.path
            else:
                tooltip(f"无法获取文件路径，可用属性: {attrs}")
                return
    else:
        # 兼容旧版 Anki
        filename = str(tag)
        import re
        match = re.search(r'sound:(.*?)(?:\]|$)', filename)
        if match:
            filename = match.group(1)
    
    # 获取 Anki 媒体文件夹路径
    from aqt import mw  # 添加这行导入 mw
    media_dir = os.path.join(mw.pm.profileFolder(), "collection.media")
    full_path = os.path.join(media_dir, filename)
    
    # 检查文件是否存在
    if not os.path.exists(full_path):
        tooltip(f"文件不存在: {full_path}")
        return
    
    # 从配置中获取 MPV 路径和设置
    config = mw.addonManager.getConfig(__name__) or {}
    mpv_path = config.get("mpv_path", "/opt/homebrew/bin/mpv")
    keep_open = config.get("keep_open", True)
    
    # 构建 MPV 命令行参数
    mpv_args = [mpv_path, "--window-scale=1.5"]
    
    # 如果设置了保持窗口打开，添加相应参数
    if keep_open:
        mpv_args.append("--keep-open=yes")
    
    # 添加窗口位置记忆功能
    mpv_args.extend(["--save-position-on-quit", "--geometry=50%:50%"])
    
    # 添加媒体文件路径
    mpv_args.append(full_path)
    
    # 使用 MPV 播放文件
    try:
        subprocess.Popen([mpv_path, "--window-scale=1.5", full_path], 
                         stdout=subprocess.DEVNULL, 
                         stderr=subprocess.DEVNULL)
        return True
    except Exception as e:
        tooltip(f"MPV 播放失败: {str(e)}")
        return False

# 注册钩子函数
def setup_hooks():
    # 替换 Anki 的默认音频播放器
    original_play_av_tags = av_player.play_tags
    
    def wrapped_play_tags(tags, *args, **kwargs):
        # 如果是音频文件，使用 MPV 播放
        for tag in tags:
            if isinstance(tag, SoundOrVideoTag):
                if play_with_mpv(tag):
                    return
        # 其他类型的标签或MPV播放失败时使用原始播放器
        return original_play_av_tags(tags, *args, **kwargs)
    
    av_player.play_tags = wrapped_play_tags

# 添加菜单项，用于切换插件状态
def add_menu_item():
    from aqt import mw
    from aqt.qt import QAction, qconnect
    
    # 检查菜单项是否已存在
    for action in mw.form.menuTools.actions():
        if action.text() == "MPV播放器开关":
            # 菜单项已存在，不再添加
            return
    
    # 创建菜单项
    action = QAction("MPV播放器开关", mw)
    qconnect(action.triggered, toggle_mpv_plugin)
    
    # 将菜单项添加到工具菜单
    mw.form.menuTools.addAction(action)

# 切换插件状态的函数
def toggle_mpv_plugin():
    from aqt import mw
    
    # 获取当前配置
    config = mw.addonManager.getConfig(__name__) or {}
    
    # 切换启用状态
    current_state = config.get("enabled", True)
    config["enabled"] = not current_state
    
    # 保存配置
    mw.addonManager.writeConfig(__name__, config)
    
    # 显示状态提示
    new_state = "启用" if config["enabled"] else "禁用"
    tooltip(f"MPV播放器已{new_state}")

# 启动插件
gui_hooks.profile_did_open.append(setup_mpv_on_startup)
gui_hooks.profile_did_open.append(lambda: add_menu_item())
setup_hooks()
